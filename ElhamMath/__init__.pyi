# ElhamMath/__init__.pyi
from __future__ import annotations
from typing import Sequence, Iterable, Mapping, Optional, overload, Literal, List, Tuple, Union
from .ElhamMath import (  # type: ignore
    Tensor as _CTensor,
    Variable as _CVariable,
    Constant as _CConstant,
    variable as _variable,
    constant as _constant,
    Device,
)


# Minimal enum mirror (typing only). If you bind Device in C++, this will be ignored at runtime.
class Device:
    CPU: Literal[0]
    CUDA: Literal[1]
TensorLike = Union[
    float,
    List[float],
    List[List[float]],
    List[List[List[float]]],
    List[List[List[List[float]]]],
    # extend if you want deeper nesting
]
class Tensor(_CTensor):
    """A dense tensor in row-major order."""
    shape: Tuple[int, ...]
    device: Device
    data: List[float]
    @overload
    def __init__(self, value: float, device: Device = Device.CPU): ...
    @overload
    def __init__(self, value: Sequence[float], device: Device = Device.CPU): ...
    @overload
    def __init__(self, value: Sequence[Sequence[float]], device: Device = Device.CPU): ...
    @overload
    def __init__(self, value: Sequence[Sequence[Sequence[float]]], device: Device = Device.CPU): ...
    @overload
    def __init__(self, value: Sequence[Sequence[Sequence[Sequence[float]]]], device: Device = Device.CPU): ...
    
    def __init__(self, value: TensorLike, device: Device = Device.CPU):
        super().__init__(value, device)  # uses C++ nested-list ctor
    def size(self) -> int: ...
    def is_scalar(self) -> bool: ...
    def desc(self) -> str: ...

class Node:
    """Abstract differentiable node."""
    name: str
    value: Tensor
    grad: Tensor
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class Operator(Node): ...
class UnaryOperator(Node): ...

class Variable(Node):
    """Leaf variable (grad accumulates)."""
    # Depending on your binding, you may accept Tensor or float.
    @overload
    def __init__(self, value: Tensor, name: str) -> None: ...
    @overload
    def __init__(self, value: float, name: str) -> None: ...

class Constant(Node):
    """Leaf constant (no grad flows into it)."""
    @overload
    def __init__(self, value: Tensor, name: str) -> None: ...
    @overload
    def __init__(self, value: float, name: str) -> None: ...

# ---- Binary operators (return a Node) ----
class add(Operator):
    def __init__(self, x1: Node, x2: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...


class sub(Operator):
    def __init__(self, x1: Node, x2: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...


class mul(Operator):
    def __init__(self, x1: Node, x2: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class divide(Operator):
    def __init__(self, numerator: Node, denominator: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class power(Operator):
    def __init__(self, x: Node, p: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class log_base(Operator):
    def __init__(self, x: Node, base: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class matmul(Operator):
    def __init__(self, A: Node, B: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class dot(Operator):
    def __init__(self, a: Node, b: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class cross(Operator):
    def __init__(self, a: Node, b: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

# ---- Unary operators ----
class ln(UnaryOperator):
    def __init__(self, x: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class exp(UnaryOperator):
    def __init__(self, x: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class sqrt(UnaryOperator):
    def __init__(self, x: Node, name: str = ...) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self, g: Tensor) -> None: ...

class Graph:
    """Computation graph wrapper."""
    nodes: Mapping[str, Node]
    def __init__(self, root: Node) -> None: ...
    def forward(self) -> Tensor: ...
    def backward(self) -> None: ...
    def printGrads(self) -> None: ...
